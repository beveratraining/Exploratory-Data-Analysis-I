---
title: "Health disparities in diabetes, treatments""
author: "Y Phillips"
date: "3/24/2022"
output: pdf document
---

#articles:
#https://diabetesjournals.org/care/article/40/3/332/36967/Glyburide-Versus-Metformin-and-Their-Combination

#https://www.diabetes.org/diabetes?&ada_source=WWP211001BW001M001CC&ada_sub_source=bing&utm_source=bing&utm_medium=search&utm_campaign=awareness-campaign&utm_term=memorial&utm_content=ad&autologin=true&s_src=AAP181101LXXXXM001CC%E2%80%9D&&msclkid=3cd386b072a118068192e4c9ca0201c5&utm_source=bing&utm_medium=cpc&utm_campaign=Awareness_Generic_ADA_%20DiabetesTypes_PH&utm_term=diabetes%20information&utm_content=Diabetes-Types-Info&gclid=3cd386b072a118068192e4c9ca0201c5&gclsrc=3p.ds

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(magrittr)
library(jmv)      ## Provides us with various correlation tools
options(scipen=999,digits=3)
```

import data
```{r}
#maneuvering to the location of the file
#diabetic_data.csv
diabetes <- read.csv(file.choose())

#importing straight from the location of the data
#diabetes <- read.table("diabetic_data.csv", sep=",", header=TRUE)
 
View(diabetes)
```

#confirm the dimensions (rows,columns).
```{r}
dim(diabetes)
```

#Making all UPPERCASE
```{r}
diabetes$gender<-toupper(diabetes$gender)
```

#Making all lowercase
```{r}
diabetes$gender<-tolower(diabetes$gender)
```

#Convert First letter of every word to Uppercase
```{r}
library(stringr)
diabetes$gender<-str_to_title(diabetes$gender)
```

```{r}
library(skimr) #gives a great overview of the dataset WITH PLOTS!!
skimr::skim(diabetes)
```
#First thing to be noticed is that there is 100% complete rate. From observation of diabetes dataset this can not be possible. 

#change ? to "NA" missing values in a column (vector)
```{r}
diabetes$weight[diabetes$weight == "?"] <- NA
head(diabetes$weight)
```

#change ? to "NA" missing values in an entire dataset (dataframe)
```{r}
diabetes[diabetes == "?"] <- NA
```

```{r}
skim(diabetes)
```

```{r}
# Return the column names containing missing observations
list_na <- colnames(diabetes)[apply(diabetes, 2, anyNA) ]
list_na
```

```{r}
library(DataExplorer)
introduce(diabetes)
```

#Visualizing the dataset of data types including missing vars
```{r}
library(visdat)
vis_miss(diabetes[,c(3:10)])

vis_dat(diabetes[,c(3:10)])
#vis_dat(diabetes, warn_large_data=FALSE) for df with large # of cols
```

#Treating missing values using complete.cases
```{r}
#remove missing values from a vector
#x <- x[complete.cases(x)]

#remove rows with missing values in any column of data frame
db1 <- diabetes[complete.cases(diabetes), ]

#remove rows with NA in specific columns of data frame
db2 <- diabetes[complete.cases(diabetes[,c("weight")]), ] 
```

#use only complete cases
```{r}
diabetes_complete <- na.omit(diabetes)
#how many obs were dropped?

#diabetes_complete is the same as db1
```

#Replacing the NA's in a particular column with a summary statistics like median
```{r}
#summary(df$column)
#df$column[is.na(df$column)] <- median(df$column)
#summary(df$column)
```

#Look into dropping variables instead of removing obs until more is known about the data set
- which variable(s) to drop; missing variables with >50% of obs
```{r}
#use the matrix[row,column] syntax
#removing weight column
diabetes <- diabetes[,-6]
```

How many variables does my dataset have and what are their types?
identify which variables should be factors? character? numeric?
```{r}
str(diabetes)
```

```{r}
diabetes$race <- factor(diabetes$race)
diabetes$gender <- factor(diabetes$gender)
diabetes$age <- factor(diabetes$age)
diabetes$admission_type_id <- factor(diabetes$admission_type_id)
diabetes$discharge_disposition_id <- character(diabetes$discharge_disposition_id)
```

How many duplicate rows are there if any?
```{r}
udb <- unique(diabetes)
dim(udb)
```

To probe further, which are the duplicate rows?
```{r}
library(janitor)
dupv <- get_dupes(diabetes)
dupv 
```

#Univarite analysis

#reports the following statistics: min, max, mean, median, 1st/3rd quartile for continuous variables, number of NA’s, and the number of observations per level for categorical variables
```{r}
summary(diabetes)
summary(diabetes$num_lab_procedures)
```

describe, outputs includes min, max, median, mean, trimmed mean, range, skewness, kurtosis
```{r}
library(psych)
describe(diabetes)
```

#frequency table with cuts
```{r}
table(cut(diabetes$time_in_hospital, seq.int(1,100,10)))
#can change the 3rd input to change segmentation endpoint
```

```{r}
hist(diabetes$time_in_hospital,
  xlab = "Time (day)",
  main = "Histogram of Time in hospital"
) 
```

```{r}
library(funModeling)
plot_num(diabetes[c(1:2000),c(6:18)])
```

```{r}
library(dataMaid)
makeDataReport(diabetes)
```

#Univariate Group Statistics (Quant vs. Qual)

```{r}
tapply(diabetes$time_in_hospital,diabetes$race,mean, na.rm=TRUE)
```

```{r}
# psych helps with descriptive statistics
psych::describeBy(diabetes$num_lab_procedures, group=diabetes$diabetesMed, na.rm=TRUE)
```

#Univariate Outlier Detection
```{r}
library(extremevalues)
L <- getOutliers(diabetes$num_medications)
outlierPlot(diabetes$num_medications,L)
```
Outliers are visible in the upper right corner. A Q–Q plot is a plot of the quantiles of two distributions against each other, or a plot based on estimates of the quantiles.

```{r}
hist(diabetes$num_medications,
  xlab = "Number of medications",
  main = "Histogram of Number of medications",
  breaks = sqrt(nrow(diabetes))
) # set number of bins
```

#also useful to detect potential outliers
```{r}
summary(diabetes$num_medications)

boxplot(diabetes$num_medications,
  ylab = "Number of Medications"
)
mtext(paste("Outliers: ", paste(out, collapse = ", ")))
#extract the values of the potential outliers based on the IQR criterion
```

```{r}
boxplot.stats(diabetes$num_medications)$out

out <- boxplot.stats(diabetes$num_medications)$out
out_ind <- which(diabetes$num_medications %in% c(out))
ut <-data.frame(out_ind)
```

#all observations that lie outside the interval formed by the 2.5 and 97.5 percentiles will be considered as potential outliers. Other percentiles such as the 1 and 99, or the 5 and 95 percentiles can also be considered to construct the interval.
```{r}
lower_bound <- quantile(diabetes$num_medications, 0.025)
lower_bound

upper_bound <- quantile(diabetes$num_medications, 0.975)
upper_bound
```
#all observations below 4 and above 36 will be considered as potential outliers.

```{r}
outlier_ind <- which(diabetes$num_medications < lower_bound | diabetes$num_medications > upper_bound)
outlier_ind
```

```{r}
outlier <- data.frame(diabetes[outlier_ind, ])
```

```{r}
library(dlookr)
dlookr::diagnose_outlier(diabetes[,c(13:14)])
plot_outlier(diabetes[,c(13:14)])
```


#Analyzing categorical variables in R

#Notice how R knows how to summarize each variable. If it’s categorical, it just lists the frequencies of
each category (we call that a frequency table, displaying the distribution of the categorical variable). 
#If a variable is quantitative, R gives summary statistics (often called a 5 number summary). 

#Watch out for categories that are entered as all numbers – R will think they are quantitative and you will have to override.

#subsetting data using matrix property []
```{r}
d <- subset(diabetes[,c("race","gender","payer_code")])
```

```{r}
library(inspectdf)
show_plot(inspect_cat(d))
```

#summarizing a categorical variable using summary function - no information
```{r}
summary(diabetes$race)
```

#the command table() works and is more useful
```{r}
table1 <-table(diabetes$race)
table1

table2 <-table(diabetes$payer_code)
table2
```

To get percentages (of the total) in each cell you can use the function prop.table().
```{r}
table1.perc = 100*prop.table(table1)
table1.perc
```

#Now for some useful graphs.
```{r}
barplot(table1, pch=9)

```

plot the bars horizontally by using the option horiz=TRUE:
barplot(table1, horiz=TRUE)
# to change the order in which the categories are displayed, i.e., have category white first,
than milk and then dark
```{r}
barplot(table1[c(3,1,4,5,2)])
```

#
```{r}
barplot(table1, main="Sample from Medical Report", 
        xlab="Race of People in Diabetes dataset", 
        ylab="Count", 
        col="brown")
```

#with percentage instead of counts on the y axis.
```{r}
barplot(table1.perc, main="Sample from Medical Report", 
                     xlab="Race", 
                     ylab="Percent (%)", col="yellow")
```

```{r}
barplot(table1.perc, main="Sample from Medical Report",        xlab="Race", 
       ylab="Percent (%)", 
       col=c("slategray4", "salmon4", "palegreen1", "orange3","black"))
```

#find out about all the available colors.
```{r}
colors() 
```

#An alternative display is a pie-chart
```{r}
pie(table1, main="Distribution of Race")

#pie(table1, main="Distribution of Race",col=c("", "", "", "","", ""))
#to override the default colors. 
```

```{r}
prop.table(table2)
```
#This is called the joint distribution.

#get row (and column) percentages, i.e., the conditional distributions, i.e., the distribution of preferred type of chocolate given the student was female (first row), and given that he was male (second row) by typing

```{r}
100*prop.table(table2,1) 
# multiplied by 100 to get percent instead of proportion
```

#stacked barplot
```{r}
barplot(table2, legend=TRUE, main="Readmitted \n by Diabetes Meds")
```
#For each type, the counts are broken down by medication.

#It is always a good idea to plot the proportions instead of the frequencies.
#This is best done in a side-by-side barchart, where for each given type of chocolate (think conditional distribution) the bars show the percent female
and male.
```{r}
barplot(100*prop.table(table2,2), legend=TRUE, main=" \n by Gender", 
        beside=TRUE, 
        ylim=c(0,80), 
        ylab="Percent",
args.legend=list(x="topleft"))
```

#informative way to visualize the data is to construct a mosaic plot.
```{r}
mosaicplot(table2,
           col=rainbow(3),
           # shade is used to plot colored chart
           shade=TRUE,
           main=" \n by Gender")
```

#Mosaic Plots are used to show symmetries for tables that are divided into two or more conditional distributions. Mosaic plots are a great way to visualize hierarchical data. A collection of rectangles represents all the elements to be visualized with the rectangles of different sizes and colors makes a table, but what makes these mosaic charts unique is the arrangement of the elements where there is a hierarchy those elements are collected and labeled together, perhaps even with subcategories. So mosaic plots can be used for plotting categorical data very effectively, with the area of the data showing the relative proportions.


#two categorical variables together, 
#i.e. Diabetes medications and readmittance 
```{r}
table3 = table(diabetes$diabetesMed,diabetes$readmitted)
table3

barplot(table3)
```

#cross tabulations of 2 variables
```{r}
library(crosstable)
crosstable(diabetes, c(gender, age), by=diabetesMed) %>%
  as_flextable(keep_id=TRUE)
```

#insights from performing independence tests on contingency tables
```{r}
library(gmodels)
t2<-CrossTable(diabetes$diabetesMed,diabetes$readmitted,chisq=TRUE)

t2$prop.tbl
```

# Create new variable derived from bmi
```{r}
diabetes$wi10days <- ifelse(diabetes$time_in_hospital>10,"yes","no")

# By obesity status
psych::describeBy(diabetes$num_procedures,diabetes$wi10days)

pairs.panels(diabetes[c("gender", "admission_type_id", "num_procedures")])
```
#the describeBy table command creates frequency counts for each combination of levels of the two variables. (You can do even more variables, or change the order of list.

#Automatic EDA

```{r}
diabetes$diabetesMed <- factor(diabetes$diabetesMed)
library(DataExplorer)
create_report(diabetes[,c(3:15,48,49)],
y="diabetesMed")
```

```{r}
library(ExPanDaR)
ExPanD(diabetes[,c(3:15)])
```

#Correlations

```{r}
library(DataExplorer)
plot_correlation(diabetes[,c(13:18)])
```

```{r}
library(PerformanceAnalytics)
chart.Correlation(diabetes[c(1:1000),c(13:18)], histogram=TRUE)
```







